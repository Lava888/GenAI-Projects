from langchain_core.documents import Document
 
 
embeddings = HuggingFaceEmbeddings()
 
 
 
 
 
 
document_1 = Document(page_content="alist command is used for alarm listing on APG node", metadata={"command": "alist"})
document_2 = Document(page_content="mml command is used for connecting to CP from APG", metadata={"command": "mml"})
document_3 = Document(page_content="netls command is used for network listing in APG", metadata={"command": "netls"})
document_4 = Document(page_content="afpls command is used for listing traffic files in APG", metadata={"command": "afpls"})
 
documents = [document_1, document_2, document_3, document_4]
ids = ["1", "2", "3","4"]
 
documents = [
    "Document one text goes here...",
    "Document two text is all about something interesting...",
    # Add as many documents as you need
]
 
documents = [ "alist command is used for alarm listing", "netls command is used for network listing"]
db=FAISS.from_texts(documents, embeddings)
 
ret = db.as_retriever(k=1)
ret.invoke("what is alarm listing command")
 
import operator

from datetime import datetime

from typing import Annotated, TypedDict, Union, Literal, Optional

from langchain.agents import create_react_agent

from langchain_core.agents import AgentAction, AgentFinish

from langchain_core.messages import BaseMessage

from langchain_core.tools import tool

from langgraph.graph import END, StateGraph

from langgraph.prebuilt import ToolNode

from langchain.prompts import PromptTemplate

from langchain_huggingface import HuggingFaceEmbeddings

from langchain_community.vectorstores import FAISS

import paramiko
 
import faiss
 
embeddings = HuggingFaceEmbeddings()
 
nc = {"bsc":"bsc,localhost,asif,rootroot","msc":"msc,localhost,asif,rootroot","hlr":"hlr,localhost,asif,rootroot"}
 
documents = [ "alist command is used for alarm listing", "netls command is used for network listing"]

db=FAISS.from_texts(documents, embeddings)
 
@tool
def lookupcommand(query: str) -> str:
    """Fetch or lookup for the requested command or command information."""
    res = compression_command_retriever.invoke(query)
    #for doc in res:
    #    print(doc)
    return "\n\n".join([doc.page_content for doc in res])
 
@tool
def connectnode(nodename: str):
    """Connect or login to node """
 
    if nodename =="":
        return "Node name is missing"
    print(nodename)
    nodename = nodename.strip()
    nodename, sep, tail = nodename.partition('\n')
    print(len(nodename))
    global selected_node
    global nc
    print(nc.keys())
    if nodename in nc.keys():
        creds = nc[nodename]
        print("Credssssssssssss",creds)
    else:
        print("Node is not available")
        return "Node not available"
    shell = ""
    session = ""
    if bool(node_sessions) and nodename in node_sessions:
        session = node_sessions[nodename]
        print(session)
 
    print("SESSSIONNNN:",session)
    if session == "" or session == None or "EOF" in str(session):
        print("Connecting new session")
        credentials=str(creds).split(",")
        client=paramiko.client.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect(str(credentials[1]),port=22,username=str(credentials[2]),password=str(credentials[3]))
        shell=client.invoke_shell()
        if shell:
            node_sessions[nodename]=shell
            selected_node = nodename
            with open('./data/connected.txt', 'w') as file:
                file.write(nodename)
                file.close()            
            return "Successfully connected to the node"
        else:
            return "Failed to connect to node. Invalid credentials or node is down."
    else:
        print("Session already exist")
        shell = node_sessions[nodename]
        selected_node = nodename
        with open('./data/connected.txt', 'w') as file:
            file.write(nodename)
            file.close()  
        return "Found active session for node.Successfully connected to the node."
 
@tool
def executecommand(command: str) -> str:
    """execute, apply, fix or run command,solution, procedure, remedies on the specified node"""
    global selected_node
    session = ""
    output = "Cannot execute command"
    print("Selected node is:",selected_node)
    print("COMMAND :",command)
    if selected_node != "":
        if bool(node_sessions) and selected_node in node_sessions:
            session = node_sessions[selected_node]
            session.send(command + "\n")
            time.sleep(5)
            output = session.recv(-1).decode("utf-8")
            print("Executing command on node:",output)
            with open('./data/agent_status.txt', 'a') as file:
                file.write(output)
                file.write("\n")
                file.close()
       
            return output
        else:
            output = "Node not connected. Make sure to connect to the node before executing the command"
            return output
    else:
        output = "Node not connected. Make sure to connect to the node before executing the command"
        return output
 
    print("Executing command on node:",output)
    return output
 
@tool
def disconnectnode(nodename: str) -> str:
    """Disconnect or shutdown or close the requested node."""
    print("Disconnecting node :",nodename)
    global selected_node
    if bool(node_sessions) and nodename in node_sessions:
        session = node_sessions[nodename]
        if session =="" or session == None or "EOF" in str(session):
            return "Node already disconnected"
        else:
            node_sessions[nodename].shutdown(2)
            node_sessions[nodename] = None
            if selected_node == nodename:
                selected_node = ""
                with open('./data/connected.txt', 'w') as file:
                    file.write(selected_node)
                    file.close()
            return "Successfully disconnected from the node"
    else:
        return "Node not found"
 
@tool
def listnodes(query) -> str:
    """list or display available nodes."""
    nl = ""
    al = "Available nodes are: "
    if bool(nc):
        nl = " ".join([key for key in nc])
        al = al + nl
        return al
    else:
        print("Node not available")
        return al
 
 
 ======================================================
 
 import operator
from datetime import datetime
from typing import Annotated, TypedDict, Union, Literal, Optional
from langchain.agents import create_react_agent
from langchain_core.agents import AgentAction, AgentFinish
from langchain_core.messages import BaseMessage
from langchain_core.tools import tool
from langgraph.graph import END, StateGraph
from langgraph.prebuilt import ToolNode
from langchain.prompts import PromptTemplate
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_community.vectorstores import FAISS
import paramiko
 
import faiss
 
embeddings = HuggingFaceEmbeddings()
 
nc = {"bsc":"bsc,localhost,asif,rootroot","msc":"msc,localhost,asif,rootroot","hlr":"hlr,localhost,asif,rootroot"}
 
documents = [ "alist command is used for alarm listing", "netls command is used for network listing"]
db=FAISS.from_texts(documents, embeddings)
 
@tool
def lookupcommand(query: str) -> str:
    """Fetch or lookup for the requested command or command information."""
    ret = db.as_retriever()
    res = ret.invoke(query)
    #for doc in res:
    #    print(doc)
    return "\n\n".join([doc.page_content for doc in res])

@tool
def connectnode(nodename: str):
    """Connect or login to node """
    if nodename =="":
        return "Node name is missing"
    print(nodename)
    nodename = nodename.strip()
    nodename, sep, tail = nodename.partition('\n')
    print(len(nodename))
    global selected_node
    global nc
    print(nc.keys())
    if nodename in nc.keys():
        creds = nc[nodename]
        print("Credssssssssssss",creds)
    else:
        print("Node is not available")
        return "Node not available"
    shell = ""
    session = ""
    if bool(node_sessions) and nodename in node_sessions:
        session = node_sessions[nodename]
        print(session)
    print("SESSSIONNNN:",session)
    if session == "" or session == None or "EOF" in str(session):
        print("Connecting new session")
        credentials=str(creds).split(",")
        client=paramiko.client.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect(str(credentials[1]),port=22,username=str(credentials[2]),password=str(credentials[3]))
        shell=client.invoke_shell()
        if shell:
            node_sessions[nodename]=shell
            selected_node = nodename
            return "Successfully connected to the node"
        else:
            return "Failed to connect to node. Invalid credentials or node is down."
    else:
        print("Session already exist")
        shell = node_sessions[nodename]
        selected_node = nodename
        return "Found active session for node.Successfully connected to the node."

 
@tool
def executecommand(command: str) -> str:
    """execute, apply, fix or run command,solution, procedure, remedies on the specified node"""
    global selected_node
    session = ""
    output = "Cannot execute command"
    print("Selected node is:",selected_node)
    print("COMMAND :",command)
    if selected_node != "":
        if bool(node_sessions) and selected_node in node_sessions:
            session = node_sessions[selected_node]
            session.send(command + "\n")
            time.sleep(5)
            output = session.recv(-1).decode("utf-8")
            print("Executing command on node:",output)
            return output
        else:
            output = "Node not connected. Make sure to connect to the node before executing the command"
            return output
    else:
        output = "Node not connected. Make sure to connect to the node before executing the command"
        return output
    print("Executing command on node:",output)
    return output
@tool
def disconnectnode(nodename: str) -> str:
    """Disconnect or shutdown or close the requested node."""
    print("Disconnecting node :",nodename)
    global selected_node
    if bool(node_sessions) and nodename in node_sessions:
        session = node_sessions[nodename]
        if session =="" or session == None or "EOF" in str(session):
            return "Node already disconnected"
        else:
            node_sessions[nodename].shutdown(2)
            node_sessions[nodename] = None
            if selected_node == nodename:
                selected_node = ""
                return "Successfully disconnected from the node"
    else:
        return "Node not found"
@tool
def listnodes(query) -> str:
    """list or display available nodes."""
    nl = ""
    al = "Available nodes are: "
    if bool(nc):
        nl = " ".join([key for key in nc])
        al = al + nl
        return al
    else:
        print("Node not available")
        return al
		
		
=========================================================


import operator
from datetime import datetime
from typing import Annotated, TypedDict, Union, Literal, Optional
from langchain.agents import create_react_agent
from langchain_core.agents import AgentAction, AgentFinish
from langchain_core.messages import BaseMessage
from langchain_core.tools import tool
from langgraph.graph import END, StateGraph
from langgraph.prebuilt import ToolNode
from langchain.prompts import PromptTemplate
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_community.vectorstores import FAISS
import paramiko
 
import faiss
 
 
global node_sessions
node_sessions={}
 
embeddings = HuggingFaceEmbeddings()
 
nc = {"bsc":"bsc,localhost,asif,rootroot","msc":"msc,localhost,asif,rootroot","hlr":"hlr,localhost,asif,rootroot"}
 
documents = [ "alist command is used for alarm listing", "netls command is used for network listing"]
db=FAISS.from_texts(documents, embeddings)
 
@tool
def lookupcommand(query: str) -> str:
    """Fetch or lookup for the requested command or command information."""
    ret = db.as_retriever()
    res = ret.invoke(query)
    #for doc in res:
    #    print(doc)
    return "\n\n".join([doc.page_content for doc in res])

@tool
def connectnode(nodename: str):
    """Connect or login to node """
    if nodename =="":
        return "Node name is missing"
    print(nodename)
    nodename = nodename.strip()
    nodename, sep, tail = nodename.partition('\n')
    print(len(nodename))
    global selected_node
    global nc
    print(nc.keys())
    if nodename in nc.keys():
        creds = nc[nodename]
        print("Credssssssssssss",creds)
    else:
        print("Node is not available")
        return "Node not available"
    shell = ""
    session = ""
    if bool(node_sessions) and nodename in node_sessions:
        session = node_sessions[nodename]
        print(session)
    print("SESSSIONNNN:",session)
    if session == "" or session == None or "EOF" in str(session):
        print("Connecting new session")
        credentials=str(creds).split(",")
        client=paramiko.client.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect(str(credentials[1]),port=22,username=str(credentials[2]),password=str(credentials[3]))
        shell=client.invoke_shell()
        if shell:
            node_sessions[nodename]=shell
            selected_node = nodename
            return "Successfully connected to the node"
        else:
            return "Failed to connect to node. Invalid credentials or node is down."
    else:
        print("Session already exist")
        shell = node_sessions[nodename]
        selected_node = nodename
        return "Found active session for node.Successfully connected to the node."

 
@tool
def executecommand(command: str) -> str:
    """execute, apply, fix or run command,solution, procedure, remedies on the specified node"""
    global selected_node
    session = ""
    output = "Cannot execute command"
    print("Selected node is:",selected_node)
    print("COMMAND :",command)
    if selected_node != "":
        if bool(node_sessions) and selected_node in node_sessions:
            session = node_sessions[selected_node]
            session.send(command + "\n")
            time.sleep(5)
            output = session.recv(-1).decode("utf-8")
            print("Executing command on node:",output)
            return output
        else:
            output = "Node not connected. Make sure to connect to the node before executing the command"
            return output
    else:
        output = "Node not connected. Make sure to connect to the node before executing the command"
        return output
    print("Executing command on node:",output)
    return output
@tool
def disconnectnode(nodename: str) -> str:
    """Disconnect or shutdown or close the requested node."""
    print("Disconnecting node :",nodename)
    global selected_node
    if bool(node_sessions) and nodename in node_sessions:
        session = node_sessions[nodename]
        if session =="" or session == None or "EOF" in str(session):
            return "Node already disconnected"
        else:
            node_sessions[nodename].shutdown(2)
            node_sessions[nodename] = None
            if selected_node == nodename:
                selected_node = ""
                return "Successfully disconnected from the node"
    else:
        return "Node not found"
@tool
def listnodes(query) -> str:
    """list or display available nodes."""
    nl = ""
    al = "Available nodes are: "
    if bool(nc):
        nl = " ".join([key for key in nc])
        al = al + nl
        return al
    else:
        print("Node not available")
        return al
 =======================================================
 
 import sqlite3
 
# Connect to (or create) the database
conn = sqlite3.connect('medicine_inventory.db')
cursor = conn.cursor()
 
# Create the medicine table
cursor.execute('''
    CREATE TABLE IF NOT EXISTS medicine (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        content TEXT NOT NULL,
        manufacture_date DATE NOT NULL,
        expiry_date DATE NOT NULL,
        stock INTEGER NOT NULL,
        price REAL NOT NULL
    )
''')
 
# Commit and close
conn.commit()
conn.close()
 
 
# Connect to the database
conn = sqlite3.connect('medicine_inventory.db')
cursor = conn.cursor()
 
# Insert sample medicines
sample_medicines = [
    ('Paracetamol', '500mg Paracetamol', '2025-01-15', '2027-01-15', 100, 1.50),
    ('Ibuprofen', '200mg Ibuprofen', '2024-12-01', '2026-12-01', 150, 2.00),
    ('Amoxicillin', '250mg Amoxicillin', '2025-03-10', '2026-09-10', 80, 3.75),
    ('Cetirizine', '10mg Cetirizine', '2025-05-20', '2027-05-20', 200, 1.20),
    ('Metformin', '500mg Metformin', '2025-02-28', '2028-02-28', 120, 2.50)
]
 
cursor.executemany('''
    INSERT INTO medicine (name, content, manufacture_date, expiry_date, stock, price)
    VALUES (?, ?, ?, ?, ?, ?)
''', sample_medicines)
 
# Commit and close
conn.commit()
conn.close()
 
from langchain_community.utilities import SQLDatabase
 
db = SQLDatabase.from_uri("sqlite:///medicine_inventory.db")
print(db.dialect)
print(db.get_usable_table_names())
db.run("SELECT * FROM medicine LIMIT 10;")
 
from typing_extensions import TypedDict
from langchain.globals import set_verbose, set_debug
set_verbose(True)
set_debug(True)
 
class State(TypedDict):
    question: str
    query: str
    result: str
    answer: str
 
 
from typing import Dict, Optional
import uuid
from langchain_openai import ChatOpenAI
import httpx
from openai import OpenAI
 
 
def get_eli_chat_model(temperature: float = 0.0, model_name: str = "LLaMA3.1-8b") -> ChatOpenAI:
    # Create an instance of the OpenAI client
    async_client = httpx.Client(verify=False)
    client = OpenAI(
        api_key="eli-18edf06d-cab1-414c-b7f0-623c60eb291b",
        base_url="https://gateway.eli.gaia.gic.ericsson.se/api/openai/v1",
        http_client=async_client,
    )
    # Create an instance of ChatOpenAI
    llm = ChatOpenAI(
        model=model_name,
        temperature=0,
        max_tokens=None,
        timeout=None,
        max_retries=2,
        api_key="eli-18edf06d-cab1-414c-b7f0-623c60eb291b",
        base_url="https://gateway.eli.gaia.gic.ericsson.se/api/openai/v1",
    )
    # Now we plug the OpenAI client into our langchain-openai interface
    llm.client = client.chat.completions
    return llm
 
ans_llm = get_eli_chat_model()
 
 
from langchain_community.chat_models import ChatOllama
 
llm = ChatOllama(
    model="llama3.2:1b",
    temperature=0,
)
 
llm.invoke("What is the capital of France?")
 
from langchain_core.prompts import ChatPromptTemplate
from langchain_experimental.llms.ollama_functions import OllamaFunctions
 
llm = OllamaFunctions(model="gemma2:2b")
 
 ========================================================
 
 
 from langchain.prompts import PromptTemplate, ChatPromptTemplate, SystemMessagePromptTemplate
from pydantic import BaseModel
import re
import sqlite3
 
template = '''
Given an input question, create a syntactically correct {dialect} query to run to help find the answer.
Unless the user specifies in his question a specific number of examples they wish to obtain,
always limit your query to at most {top_k} results.
You can order the results by a relevant column to return the most interesting examples in the database.
Never query for all the columns from a specific table, only ask for a the few relevant columns given the question.
Pay attention to use only the column names that you can see in the schema description. Be careful to not query for columns that do not exist. Also, pay attention to which column is in which tables.
Only use the following tables:
{table_info}
Question: {input}
'''
system_message_prompt = SystemMessagePromptTemplate(
    prompt=PromptTemplate(
        input_variables=['dialect', 'input', 'table_info', 'top_k'],
        template=template
    )
)
query_prompt_template  = ChatPromptTemplate(
    messages=[system_message_prompt]
)
 
class SQLState(TypedDict):
    question: str
    query: str
    result: str
    answer: str
 
class QueryOutput(BaseModel):
    """Generated SQL query."""
 
    query: Annotated[str, ..., "Syntactically valid SQL query."]
 
 
def write_query(state: SQLState):
    """Generate SQL query to fetch information."""
    prompt = query_prompt_template.invoke(
        {
            "dialect": db.dialect,
            "top_k": 10,
            "table_info": db.get_table_info(),
            "input": state["question"],
        }
    )
    structured_llm = llm.with_structured_output(QueryOutput)
    result = structured_llm.invoke(prompt)
    #print(type(result))
    output = re.split("query=",str(result))
    #return(output[1])
    sql_query = output[1]
    if sql_query.startswith('"') and sql_query.endswith('"'):
       sql_query = sql_query[1:-1]
    #return sql_query
    return {"query": sql_query}
 
 
def execute_query(state: SQLState):
    """Execute SQL query."""
    conn = sqlite3.connect('medicine_inventory.db')
    cursor = conn.cursor()
    query = state["query"].strip("'\"")
    # Execute the SELECT query
    cursor.execute(query)
    # Fetch the result
    result = cursor.fetchall()
    conn.close()
    print(result)
    return {"result": str(result)}
 
 
def generate_answer(state: SQLState):
    """Answer question using retrieved information as context."""
    prompt = (
        "Given the following user question, corresponding SQL query, "
        "and SQL result, answer the user question.From SQL query result summarize the details and explain in details.Avoid explaining about SQL query. Do not mention anything about SQL while generating answer.\n\n"
        f'Question: {state["question"]}\n'
        f'SQL Query: {state["query"]}\n'
        f'SQL Result: {state["result"]}'
    )
   
    response = ans_llm.invoke(prompt)
    return {"answer": response.content}
 
 
from langgraph.graph import START, StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
sql_workflow = StateGraph(SQLState)
sql_workflow.add_node("write_query", write_query)
sql_workflow.add_node("execute_query", execute_query)
sql_workflow.add_node("generate_answer", generate_answer)
 
sql_workflow.add_edge(START, "write_query")
sql_workflow.add_edge("write_query","execute_query")
sql_workflow.add_edge( "execute_query","generate_answer")
sql_workflow.add_edge("generate_answer", END)
 
sql_memory = MemorySaver()
sql_graph = sql_workflow.compile(checkpointer=sql_memory)
print("SQL GRAPH DONE")
sql_config = {"configurable": {"thread_id": "1"}}
 
 
query = {"question": "which are the list of medicines available?"}
 
for step in sql_graph.stream(query, sql_config, stream_mode="updates"):
    print(step)
 
 
print(step['generate_answer']['answer'])
 
 
 ============================================================
 
 #######   medical report
 
 
 
 from langchain.embeddings import HuggingFaceEmbeddings
from langchain_community.vectorstores import FAISS
from langchain_core.documents import Document
from langchain.embeddings import HuggingFaceEmbeddings
from langchain_community.vectorstores import FAISS
from langchain_core.documents import Document
import streamlit as st
from langchain_openai import ChatOpenAI
import httpx
from openai import OpenAI


def get_eli_chat_model(temperature: float = 0.0, model_name: str = "qwen2.5-7b"):
    # Create an instance of the OpenAI client
    client = OpenAI(
        api_key="eli-18edf06d-cab1-414c-b7f0-623c60eb291b",
        base_url="https://gateway.eli.gaia.gic.ericsson.se/api/openai/v1",
        http_client=httpx.Client(verify=False),
    )
    # Create an instance of ChatOpenAI
    llm = ChatOpenAI(
        model=model_name,
        temperature=0,
        max_tokens=None,
        timeout=None,
        max_retries=2,
        api_key="eli-18edf06d-cab1-414c-b7f0-623c60eb291b",
        base_url="https://gateway.eli.gaia.gic.ericsson.se/api/openai/v1",
    )
    # Now we plug the OpenAI client into our langchain-openai interface
    llm.client = client.chat.completions
    return llm

# Load your custom CSV
import pandas as pd
df = pd.read_csv("testdata.csv")

# Create documents using symptoms as content
documents = [
    Document(page_content=row["Symptoms"], metadata={"disease": row["Disease"], "treatment": row["Treatment"]})
    for _, row in df.iterrows()
]

# Embed and store
embedding_model = HuggingFaceEmbeddings(model_name="all-MiniLM-L6-v2")
db = FAISS.from_documents(documents, embedding_model)


results = []

def resp_tool(query):
    retriever = db.as_retriever(k=1)
#query = "I have fever and joint pain with rash"
    results = retriever.invoke(query)
# Extract metadata
    
#    disease = match.metadata["disease"]
 #   treatment = match.metadata["treatment"]

    return results



llm = get_eli_chat_model()

st.title("Medical Assitant")

query = st.chat_input("Enter your query here")

if query:
    with st.chat_message("user"):
        st.write(query)
    results = resp_tool(query)
    match = results[0]
    response = llm.invoke(f"""
        User symptoms: {query}
        Matched disease: {match.metadata["disease"]}
        Recommended treatment: {match.metadata["treatment"]}
        Based on user query mention that it seems you have this and 
        Explain the disease and treatment in simple terms.
        """)
    with st.chat_message("assistant"):
        st.write(response.content)


=============================================
